/*Задача 1. Будильник-колыбельная
Помогите Васе перестать просыпать на пары. Для этого нужно написать программу-будильник-колыбельную с возможностью добавления, удаления, запусков и остановки звонков.

Необходимо написать класс AlarmClock с методами:

1) constructor — выделяет память для объекта.
=Создайте свойство для хранения коллекции звонков alarmCollection с начальным значением пустого массива.
=Создайте свойство intervalId для хранения id таймера без начального значения.
2) addClock — добавляет новый звонок в коллекцию существующих.
=Принимает параметр времени в формате HH:MM — время, когда действие должно запуститься.
=Принимает параметр функции-колбека — действие, которое должно запуститься.
=Проверьте, переданы ли параметры времени и колбека. Если параметр не передан, выполните выброс ошибки с помощью throw new Error('Отсутствуют обязательные аргументы').
=Проверьте, есть ли звонок с таким же временем. Если есть, выведите предупреждение в консоль с помощью console.warn('Уже присутствует звонок на это же время').
=Перед завершением метода добавьте в массив звонков объект со свойствами callback, time, canCall. В свойстве canCall должно быть значение запуска функции колбека. Изначально значением должно быть true.
3) removeClock — удаляет звонки по определённому времени.
=Принимает time звонка, который следует удалить.
=Удалите из массива звонков те, у которых time совпадает со значением аргумента. Например, можно использовать метод filter.
4) getCurrentFormattedTime — возвращает текущее время в строковом формате HH:MM.

5) start — запускает будильник.
=Проверьте наличие значения в свойстве intervalId. Если в нём присутствует значение, то завершайте выполнение метода. Программа не должна позволять создавать несколько интервалов.
=Создавайте новый интервал, в котором каждую секунду выполняйте действия:
=Перебирайте все звонки с помощью метода forEach.
=При переборе каждый звонок проверяйте на возможность его запуска: свойство time совпадает с текущим временем, и звонок может выполняться.
=При истином условии (необходимости запуска звонка) в свойство canCall (возможность вызова звонка) присваивайте false и вызывайте колбек звонка (свойство callback).
=Результат создания интервала сохраняйте в свойство intervalId.
6) stop — останавливает выполнение интервала будильника.
=Вызовите функцию clearInterval для удаления интервала.
=Сбросьте значение из свойства intervalId. Для сброса свойства можно присваивать null.
7) resetAllCalls — сбрасывает возможность запуска всех звонков.
=С помощью метода forEach присваивайте true в свойство canCall у каждого звонка.
8) clearAlarms — удаляет все звонки.
=Вызывает метод остановки интервала (метод stop).
=Удаляет все звонки. Для удаления всех звонков переприсваивайте свойство alarmCollection в пустой массив..*/

class AlarmClock {
  constructor (){ //выделяет память для объекта.
    this.alarmCollection = []; //свойство для хранения коллекции звонков alarmCollection с начальным значением пустого массива.
    this.intervalId = null;; //свойство intervalId для хранения id таймера без начального значения.
  }
  
addClock(time, callback) { //добавляет новый звонок в коллекцию существующих
   if (!time || !callback) {
     throw new Error('Отсутствуют обязательные аргументы');
   }
  if (this.alarmCollection.some((alarm) => alarm.time === time)){
    console.warn('Уже присутствует звонок на это же время')
  }
  this.alarmCollection.push({callback, time, canCall: true});
}

removeClock(time) { // удаляет звонки по определённому времени.
    this.alarmCollection = this.alarmCollection.filter(
      (alarm) => alarm.time !== time);
}

getCurrentFormattedTime() { //возвращает текущее время в строковом формате HH:MM.
    return new Date().toLocaleTimeString([], {
      hour: "2-digit",
      minute: "2-digit",
    });
  }

start(){ //запускает будильник
  if(this.intervalId !== null){
    return;
  }
   this.intervalId = setInterval(() => this.alarmCollection.forEach((alarm) =>{
     if (alarm.time === this.getCurrentFormattedTime() && alarm.canCall){
        alarm.canCall = false;
       alarm.callback(); }
        }),
      1000
   );
}

stop() {
  clearInterval(this.intervalId);
  this.intervalId = null;
}

resetAllCalls(){ //сбрасывает возможность запуска всех звонков
  this.alarmCollection.forEach(alarm => alarm.canCall = true)
}
                               
clearAlarms() { //удаляет все звонки
    this.stop();
    this.alarmCollection = [];
  }
}
